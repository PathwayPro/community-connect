"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createMergedReport = createMergedReport;
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _teleReceiver = require("../isomorphic/teleReceiver");
var _reporters = require("../runner/reporters");
var _multiplexer = require("./multiplexer");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

async function createMergedReport(config, dir, reporterDescriptions, resolvePaths) {
  const shardFiles = await sortedShardFiles(dir);
  if (shardFiles.length === 0) throw new Error(`No report files found in ${dir}`);
  const events = await mergeEvents(dir, shardFiles);
  if (resolvePaths) patchAttachmentPaths(events, dir);
  const reporters = await (0, _reporters.createReporters)(config, 'merge', reporterDescriptions);
  const receiver = new _teleReceiver.TeleReporterReceiver(_path.default.sep, new _multiplexer.Multiplexer(reporters), config.config);
  for (const event of events) await receiver.dispatch(event);
}
function patchAttachmentPaths(events, resourceDir) {
  for (const event of events) {
    if (event.method !== 'onTestEnd') continue;
    for (const attachment of event.params.result.attachments) {
      if (!attachment.path) continue;
      attachment.path = _path.default.join(resourceDir, attachment.path);
    }
  }
}
function parseEvents(reportJsonl) {
  return reportJsonl.toString().split('\n').filter(line => line.length).map(line => JSON.parse(line));
}
async function mergeEvents(dir, shardReportFiles) {
  const events = [];
  const beginEvents = [];
  const endEvents = [];
  for (const reportFile of shardReportFiles) {
    const reportJsonl = await _fs.default.promises.readFile(_path.default.join(dir, reportFile), 'utf8');
    const parsedEvents = parseEvents(reportJsonl);
    for (const event of parsedEvents) {
      if (event.method === 'onBegin') beginEvents.push(event);else if (event.method === 'onEnd') endEvents.push(event);else if (event.method === 'onBlobReportMetadata') new ProjectNamePatcher(event.params.projectSuffix).patchEvents(parsedEvents);else events.push(event);
    }
  }
  return [mergeBeginEvents(beginEvents), ...events, mergeEndEvents(endEvents), {
    method: 'onExit',
    params: undefined
  }];
}
function mergeBeginEvents(beginEvents) {
  if (!beginEvents.length) throw new Error('No begin events found');
  const projects = [];
  let config = {
    configFile: undefined,
    globalTimeout: 0,
    maxFailures: 0,
    metadata: {
      totalTime: 0
    },
    rootDir: '',
    version: '',
    workers: 0,
    listOnly: false
  };
  for (const event of beginEvents) {
    config = mergeConfigs(config, event.params.config);
    const shardProjects = event.params.projects;
    for (const shardProject of shardProjects) {
      const mergedProject = projects.find(p => p.id === shardProject.id);
      if (!mergedProject) projects.push(shardProject);else mergeJsonSuites(shardProject.suites, mergedProject);
    }
  }
  return {
    method: 'onBegin',
    params: {
      config,
      projects
    }
  };
}
function mergeConfigs(to, from) {
  return {
    ...to,
    ...from,
    metadata: {
      ...to.metadata,
      ...from.metadata,
      totalTime: to.metadata.totalTime + from.metadata.totalTime
    },
    workers: to.workers + from.workers
  };
}
function mergeJsonSuites(jsonSuites, parent) {
  for (const jsonSuite of jsonSuites) {
    const existingSuite = parent.suites.find(s => s.title === jsonSuite.title);
    if (!existingSuite) {
      parent.suites.push(jsonSuite);
    } else {
      mergeJsonSuites(jsonSuite.suites, existingSuite);
      existingSuite.tests.push(...jsonSuite.tests);
    }
  }
}
function mergeEndEvents(endEvents) {
  const result = {
    status: 'passed'
  };
  for (const event of endEvents) {
    const shardResult = event.params.result;
    if (shardResult.status === 'failed') result.status = 'failed';else if (shardResult.status === 'timedout' && result.status !== 'failed') result.status = 'timedout';else if (shardResult.status === 'interrupted' && result.status !== 'failed' && result.status !== 'timedout') result.status = 'interrupted';
  }
  return {
    method: 'onEnd',
    params: {
      result
    }
  };
}
async function sortedShardFiles(dir) {
  const files = await _fs.default.promises.readdir(dir);
  return files.filter(file => file.endsWith('.jsonl')).sort();
}
class ProjectNamePatcher {
  constructor(_projectNameSuffix) {
    this._projectNameSuffix = _projectNameSuffix;
  }
  patchEvents(events) {
    if (!this._projectNameSuffix) return;
    for (const event of events) {
      const {
        method,
        params
      } = event;
      switch (method) {
        case 'onBegin':
          this._onBegin(params.config, params.projects);
          continue;
        case 'onTestBegin':
        case 'onStepBegin':
        case 'onStepEnd':
        case 'onStdIO':
          params.testId = this._mapTestId(params.testId);
          continue;
        case 'onTestEnd':
          params.test.testId = this._mapTestId(params.test.testId);
          continue;
      }
    }
  }
  _onBegin(config, projects) {
    for (const project of projects) project.name += this._projectNameSuffix;
    this._updateProjectIds(projects);
    for (const project of projects) project.suites.forEach(suite => this._updateTestIds(suite));
  }
  _updateProjectIds(projects) {
    const usedNames = new Set();
    for (const p of projects) {
      for (let i = 0; i < projects.length; ++i) {
        const candidate = p.name + (i ? i : '');
        if (usedNames.has(candidate)) continue;
        p.id = candidate;
        usedNames.add(candidate);
        break;
      }
    }
  }
  _updateTestIds(suite) {
    suite.tests.forEach(test => test.testId = this._mapTestId(test.testId));
    suite.suites.forEach(suite => this._updateTestIds(suite));
  }
  _mapTestId(testId) {
    return testId + '-' + this._projectNameSuffix;
  }
}